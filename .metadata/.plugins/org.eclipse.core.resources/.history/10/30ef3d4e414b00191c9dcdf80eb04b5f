package com.yoke;

import java.awt.AWTException;
import java.awt.CheckboxMenuItem;
import java.awt.Dimension;
import java.awt.Image;
import java.awt.Menu;
import java.awt.MenuItem;
import java.awt.PopupMenu;
import java.awt.SystemTray;
import java.awt.Toolkit;
import java.awt.TrayIcon;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.List;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;

import com.sun.jna.Native;
import com.sun.jna.platform.win32.User32;
import com.sun.jna.platform.win32.WinDef.HWND;
import com.yoke.connection.Connection;
import com.yoke.connection.MessageReceiver;
import com.yoke.connection.messages.ProgramFocused;
import com.yoke.connection.messages.computerCmds.ShutDownCmd;
import com.yoke.connection.messages.computerCmds.SleepCmd;
import com.yoke.connection.messages.connection.Connected;
import com.yoke.connection.messages.connection.ConnectionFailed;
import com.yoke.connection.messages.connection.Disconnected;
import com.yoke.connection.server.MultiServerConnection;
import com.yoke.connection.server.types.BluetoothServerConnection;
import com.yoke.executors.ClickMouseExecutor;
import com.yoke.executors.MoveMouseExecutor;
import com.yoke.executors.OpenProgramExecutor;
import com.yoke.executors.OpenURLExecutor;
import com.yoke.executors.PressKeysExecutor;
import com.yoke.executors.computerCmds.LogOffExecutor;
import com.yoke.executors.computerCmds.NextTrackExecutor;
import com.yoke.executors.computerCmds.PlayPauseExecutor;
import com.yoke.executors.computerCmds.PreviousTrackExecutor;
import com.yoke.executors.computerCmds.RestartExecutor;
import com.yoke.executors.computerCmds.ShutDownExecutor;
import com.yoke.executors.computerCmds.SleepExecutor;
import com.yoke.executors.computerCmds.VirtualKeyExecutor;
import com.yoke.executors.computerCmds.VolumeDownExecutor;
import com.yoke.executors.computerCmds.VolumeUpExecutor;

/**
 * The main class for the application
 */
public class Main {
	/**
	 * Starts the program, doesn't take any arguments
	 * @param args
	 */
	public static void main(String[] args) {
		new Main();
	}
	
	// The connection to any potential remotes
	protected MultiServerConnection connection;
	
	// A list of the currently connected device IDs
	protected List<Integer> deviceIDs = new ArrayList<Integer>();
	
	// A reference to the tray
	protected Tray tray;
	
	/*
     * The constructor method
	 */
	public Main() {
        try {
            Thread.sleep((long)2000);
            User32jna u32 = User32jna.INSTANCE;
            
            //https://docs.microsoft.com/en-us/windows/desktop/inputdev/virtual-key-codes
            byte playPause = (byte)0xB3;
            u32.keybd_event((byte) playPause,(byte)0,0,0);
            
            // eventMin, eventMax, window?, procedure, processID, thread ID, flags
            // https://docs.microsoft.com/en-us/windows/desktop/WinAuto/event-constants
            // https://github.com/sancarn/ACC.AHK/blob/master/AccV2.ahk
            //0x8005
            
            HWND h = User32jna.INSTANCE.GetForegroundWindow();
            int size = User32jna.INSTANCE.GetWindowTextLengthA(h)+1;
            char[] name = new char[size];
            System.out.println(User32jna.INSTANCE.GetWindowTextA(h, name, size));
            System.out.println(size +" " +new String(name));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
		BluetoothServerConnection bluetooth = new BluetoothServerConnection();
		connection = new MultiServerConnection(bluetooth);
		
		setupConnectionListeners();
		setupExecutors();
		setupProgramPoll();
		
		// Setup the tray
		tray = Tray.getInstance();
		tray.updateConnectedDevices(deviceIDs.size());
	}
	
	public interface User32jna extends User32 {
        User32jna INSTANCE = (User32jna) Native.load("user32.dll",User32jna.class);
        public void keybd_event(byte bVk, byte bScan, int dwFlags, int dwExtraInfo);
        int GetWindowTextA(HWND  hWnd, char[] lpString, int   nMaxCount);
        int GetWindowTextLengthA(HWND hWnd);
    }
	
	/**
	 * Sets up the listeners to check connection state changes
	 */
	protected void setupConnectionListeners() {
		connection.addReceiver(new MessageReceiver<Connected>() {
			public void receive(Connected cmd) {
				// Add the device and get its index
				deviceIDs.add(cmd.deviceID);
				int index = deviceIDs.indexOf(cmd.deviceID) + 1;
				
				// Notify that a device has connected
				tray.showMessage("Panel " + index + " has connected");

				// Update how many devices are connected
				tray.updateConnectedDevices(deviceIDs.size());
			}
		});
		connection.addReceiver(new MessageReceiver<Disconnected>() {
			public void receive(Disconnected cmd) {
				// Get the index of the device, and remove it
				int index = deviceIDs.indexOf(cmd.deviceID) + 1;
				deviceIDs.remove((Object) cmd.deviceID);		
				
				// Notify that a device has connected
				tray.showMessage("Panel " + index + " has disconnected");
				
				// Go through all devices after, and indicate that index update
				for (int i = index + 1; i <= deviceIDs.size(); i++) {
					tray.showMessage("Panel " + i + " has now become panel " + (i - 1));
				}
				
				// Update how many devices are connected
				tray.updateConnectedDevices(deviceIDs.size());
			}
		});
		connection.addReceiver(new MessageReceiver<ConnectionFailed>() {
			public void receive(ConnectionFailed cmd) {		
				// Show that there was an error
				tray.showMessage("Something went wrong while connecting panel" + (cmd.description != "" ? ":" : ""));
				
				// Show the error message
				tray.showMessage(cmd.description);
				
				// Show the exact error in the console, TODO: make this accessable to the user
				if (cmd.exception != null) {
					cmd.exception.printStackTrace();
				}
			}
		});
	}
	
	/**
	 * Sets up all of the command executors
	 */
	protected void setupExecutors() {
		connection.addReceiver(new PlayPauseExecutor());
		connection.addReceiver(new PreviousTrackExecutor());
		connection.addReceiver(new NextTrackExecutor());
		connection.addReceiver(new VolumeUpExecutor());
		connection.addReceiver(new VolumeDownExecutor());
		
		connection.addReceiver(new ShutDownExecutor());
		connection.addReceiver(new SleepExecutor());
		connection.addReceiver(new RestartExecutor());
		connection.addReceiver(new LogOffExecutor());
		
		connection.addReceiver(new MoveMouseExecutor());
		connection.addReceiver(new ClickMouseExecutor());
		connection.addReceiver(new PressKeysExecutor());
		
		connection.addReceiver(new OpenProgramExecutor());
		connection.addReceiver(new OpenURLExecutor());
	}
	
	/**
	 * Sets up a function to poll for what program is selected
	 */
	protected void setupProgramPoll() {
	    // Get a reference to the settings
	    final LocalSettings settings = LocalSettings.getInstance();
	    
	    // Reuse the user32 dll of virtual key's interface
	    VirtualKeyExecutor.U32 user32 = VirtualKeyExecutor.U32.INSTANCE;
	    
	    
	    // Create a thread to perform the polling in
	    Thread thread = new Thread() {
	        // The name of the focused window
	        protected String focusedName = "";
	        
	        @Override
	        public void run() {
                try {
                    while(true) {
                        // Have a little timeout to reduce computation efforts
                        sleep(500);
                        
                        // Check if the poll should be performed
                        if (settings.getPollFocusedProgram()) {
                            // Get the window text name
                            HWND h = user32.GetForegroundWindow();
                            int size = user32.GetWindowTextLength(h) + 1;
                            char[] charList = new char[size];
                            user32.GetWindowText(h, charList, size);
                            String name = new String(charList);
                            
                            // Check if this name is different from the previous name
                            if (focusedName != name) {
                                focusedName = name;
                                
                                // Send the program focus message
                                System.out.println(name);
                                connection.send(new ProgramFocused(name));
                            }
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
	        }
	    };
	    thread.start();
	}
}
